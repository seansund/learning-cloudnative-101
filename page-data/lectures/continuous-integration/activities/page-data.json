{"componentChunkName":"component---src-pages-lectures-continuous-integration-activities-index-mdx","path":"/lectures/continuous-integration/activities/","result":{"pageContext":{"frontmatter":{"title":"Tekton Lab","description":"Lab for continuous integration using tekton"},"relativePagePath":"/lectures/continuous-integration/activities/index.mdx","titleType":"page","MdxNode":{"id":"f6c5e5d8-e920-5a09-8f68-2ea55b8a5de9","children":[],"parent":"d4dc7722-6c6f-567c-af1b-82bbd1adceec","internal":{"content":"---\ntitle: Tekton Lab\ndescription: Lab for continuous integration using tekton\n---\n\n<AnchorLinks small>\n  <AnchorLink>Prerequisites</AnchorLink>\n  <AnchorLink>SetUp</AnchorLink>\n  <AnchorLink>Create Target Namespace</AnchorLink>\n  <AnchorLink>Tasks</AnchorLink>\n  <AnchorLink>Pipelines</AnchorLink>\n  <AnchorLink>Deploy Application</AnchorLink>\n</AnchorLinks>\n\n## Prerequisites\n\nMake sure your environment is properly setup.\n\nFollow the instructions [here](../../prerequisites#environment-setup)\n<Tabs>\n\n<Tab label=\"OpenShift\">\n\n## SetUp\n\n### Tekton CLI Installation\n\n- [Tekton CLI](https://github.com/tektoncd/cli) is command line utility used to interact with the Tekton resources.\n\n- Follow the instructions on the tekton CLI github repository https://github.com/tektoncd/cli#installing-tkn\n\n- For MacOS for example you can use brew\n    ```\n    brew tap tektoncd/tools\n    brew install tektoncd/tools/tektoncd-cli\n    ```\n- Verify the Tekton cli\n    ```\n    tkn version\n    ```\n- The command should show a result like:\n    ```\n    $ tkn version\n    Client version: 0.10.0\n    ```\n- If you already have the `tkn` install you can upgrade running\n    ```\n    brew upgrade tektoncd/tools/tektoncd-cli\n    ```\n\n### Tekton Pipelines Installation\n\n- To deploy the Tekton pipelines:\n    ```\n   oc apply --filename https://raw.githubusercontent.com/ibm-cloud-architecture/learning-cloudnative-101/master/static/yamls/tekton-lab/tekton-operator.yaml\n    ```\n- ***Note***: It will take few mins for the Tekton pipeline components to be installed, you an watch the status using the command:\n    ```\n    oc get pods -n openshift-operators -w\n    ```\n    You can use `Ctrl+c` to terminate the watch\n- A successful deployment of Tekton pipelines will show the following pods:\n    ```\n    NAME                                         READY   STATUS    RESTARTS   AGE\n    openshift-pipelines-operator-9cdbbb854-x9tvs   1/1     Running   0          25s\n    ```\n\n## Create Target Namespace\n\n- Set the environment variable `NAMESPACE` to `tekton-demo`, if you open a new terminal remember to set this environment again\n    ```\n    export NAMESPACE=tekton-demo\n    ```\n- Create a the namespace using the variable `NAMESPACE`\n    ```\n    oc new-project $NAMESPACE\n    ```\n\n## Tasks\n\n### Task Creation\n\n- Create the below yaml files.\n- The following snippet shows what a Tekton Task YAML looks like:\n- Create the file **task-test.yaml**\n    ```yaml\n    apiVersion: tekton.dev/v1beta1\n    kind: Task\n    metadata:\n      name: java-test\n    spec:\n      params:\n        - name: url\n          default: https://github.com/ibm-cloud-architecture/cloudnative_sample_app\n        - name: revision\n          default: master\n      steps:\n        - name: git-clone\n          image: alpine/git\n          script: |\n            git clone -b $(params.revision) --depth 1 $(params.url) /source\n          volumeMounts:\n            - name: source\n              mountPath: /source\n        - name: test\n          image: maven:3.3-jdk-8\n          workingdir: /source\n          script: |\n            mvn test\n            echo \"tests passed with rc=$?\"\n          volumeMounts:\n            - name: m2-repository\n              mountPath: /root/.m2\n            - name: source\n              mountPath: /source\n      volumes:\n        - name: m2-repository\n          emptyDir: {}\n        - name: source\n          emptyDir: {}\n    ```\n\n- Each Task has the following:\n- **name** - the unique name using which the task can be referred\n    - name - the name of the parameter\n    - description - the description of the parameter\n    - default - the default value of parameter\n- **Note**: The `TaskRun` or `PipelineRun` could override the parameter values, if no parameter value is passed then the default value will be used.\n\n- **steps** - One or more sub-tasks that will be executed in the defined order. The step has all the attributes like a Pod spec\n- **volumes** - the task can also mount external volumes using the volumes attribute.\n- The parameters that were part of the spec inputs params can be used in the steps using the notation `$(<variable-name>)`.\n\n### Task Deploy\n\n- The application test task could be created using the command:\n    ```\n    oc apply -f task-test.yaml -n $NAMESPACE\n    ```\n\n- We will use the Tekton cli to inspect the created resources\n    ```\n    tkn task ls -n $NAMESPACE\n    ```\n\n- The above command should list one Task as shown below:\n    ```\n    NAME        AGE\n    java-test   22 seconds ago\n    ```\n\n\n### TaskRun\n\n- The [TaskRun](https://github.com/tektoncd/pipeline/blob/master/docs/taskruns.md) is used to run a specific task independently. In the following section we will run the build-app task created in the previous step\n\n#### TaskRun Creation\n\n- The following snippet shows what a Tekton TaskRun YAML looks like:\n- Create the file **taskrun-test.yaml**\n    ```yaml\n    apiVersion: tekton.dev/v1beta1\n    kind: TaskRun\n    metadata:\n      generateName: test-task-run-\n    spec:\n      taskRef:\n        name: java-test\n      params:\n        - name: url\n          value: https://github.com/ibm-cloud-architecture/cloudnative_sample_app\n    ```\n- **generateName** - since the TaskRun can be run many times, in order to have unqiue name across the TaskRun ( helpful when checking the TaskRun history) we use this generateName instead of name. When Kubernetes sees generateName it will generate unquie set of characters and suffix the same to build-app-, similar to how pod names are generated\n- **taskRef** - this is used to refer to the Task by its name that will be run as part of this TaskRun. In this example we use build-app Task.\n- As described in the earlier section that the Task inputs and outputs could be overridden via TaskRun.\n- **params** - this are the parameter values that are passed to the task\n- The application test task(java-maven-test) could be run using the command:\n    ```bash\n    kubectl create -f taskrun-test.yaml -n $NAMESPACE \n    ```\n- **Note** - As tasks will use generated name, never use `oc apply -f taskrun-test.yaml`\n- We will use the Tekton cli to inspect the created resources:\n    ```bash\n    tkn tr ls -n $NAMESPACE\n    ```\n    The above command should list one TaskRun as shown below:\n    ```bash\n    NAME                       STARTED        DURATION   STATUS\n    test-task-run-q6s8c        1 minute ago   ---        Running(Pending)\n    ```\n    **Note** - It will take few seconds for the TaskRun to show status as Running as it needs to download the container images.\n\n- To check the logs of the Task Run using the `tkn`:\n  ```bash\n  tkn tr logs -f --last -n $NAMESPACE\n  ```\n  **Note** - Each task step will be run within a container of its own.\n  The -f or -a allows to tail the logs from all the containers of the task. For more options run `tkn tr logs --help`\n- If you see the TaskRun status as Failed or Error use the following command to check the reason for error:\n    ```bash\n    tkn tr describe --last -n $NAMESPACE\n    ```\n- If it is successful, you will see something like below.\n    ```bash\n    tkn tr ls -n $NAMESPACE\n    ```\n    The above command should list one TaskRun as shown below:\n    ```bash\n    NAME                  STARTED          DURATION     STATUS\n    test-task-run   47 seconds ago   34 seconds   Succeeded\n    ```\n\n### Creating additional tasks and deploying them\n\n- Create a Task to build a container image and push to the registry\n- This task will be later used by the pipeline.\n- Download the task file [task-buildah.yaml](/yamls/tekton-lab/task-buildah.yaml) to build the image, push the image to the registy:\n- Create the `buildah` Task using the file and the command:\n    ```\n    oc apply -f task-buildah.yaml -n $NAMESPACE\n    ```\n- Use the Tekton cli to inspect the created resources\n    ```\n    tkn task ls -n $NAMESPACE\n    ```\n- The above command should list one Task as shown below:\n    ```\n    NAME              AGE\n    buildah            4 seconds ago\n    java-test         46 minutes ago\n    ```\n\n\n- Create an environment variable for location to push the image to be build. Replace `NAMESPACE` for the dockerhub username, or IBM CR Namespace\n    ```bash\n    export REGISTRY_SERVER=image-registry.openshift-image-registry.svc:5000\n    export IMAGE_URL=${REGISTRY_SERVER}/${NAMESPACE}/cloudnative_sample_app\n    echo IMAGE_URL=${IMAGE_URL}\n    ```\n- Lets create a Task Run for `buildah` Task using the `tkn` CLI passing the inputs, outputs and service account.\n    ```bash\n    tkn task start buildah --showlog \\\n      -p image=${IMAGE_URL} \\\n      -p url=https://github.com/ibm-cloud-architecture/cloudnative_sample_app \\\n      -s pipeline \\\n      -n $NAMESPACE\n    ```\n    The task will start and logs will start printing automatically\n    ```\n    Taskrun started: buildah-run-vvrg2\n    Waiting for logs to be available...\n    ```\n\n- Verify the status of the Task Run\n    ```bash\n    tkn tr ls -n $NAMESPACE\n    ```\n    Output should look like this\n    ```\n    NAME                  STARTED          DURATION     STATUS\n    buildah-run-zbsrv      2 minutes ago    1 minute     Succeeded\n    ```\n- To clean up all Pods associated with all Task Runs, delete all the task runs resources\n    ```bash\n    oc delete taskrun --all -n $NAMESPACE\n    ```\n- (Optional) Instead of starting the Task via `tkn task start` you could also use yaml TaskRun, create a file **taskrun.yaml**\n    ```yaml\n    apiVersion: tekton.dev/v1beta1\n    kind: TaskRun\n    metadata:\n      generateName: buildah-task-run-\n    spec:\n      serviceAccountName: pipeline\n      taskRef:\n        name: buildah\n      params:\n        - name: url\n          value: https://github.com/ibm-cloud-architecture/cloudnative_sample_app\n        - name: image\n          value: image-registry.openshift-image-registry.svc:5000/tekton-demo/cloudnative_sample_app\n    ```\n    Then create the TaskRun with \n    ```bash\n    oc create -f taskrun-buildah.yaml -n $NAMESPACE\n    ```\n    Follow the logs with:\n    ```\n    tkn tr logs -f -n $NAMESPACE\n    ```\n\n## Pipelines\n\n### Pipeline Creation\n\n- Pipelines allows to start multiple Tasks, in parallel or in a [certain order](https://github.com/tektoncd/pipeline/blob/master/docs/pipelines.md#runafter)\n\n- Create the file **pipeline.yaml**, the Pipeline contains two Tasks\n    ```yaml\n    apiVersion: tekton.dev/v1beta1\n    kind: Pipeline\n    metadata:\n      name: test-build\n    spec:\n      params:\n        - name: repo-url\n          default: https://github.com/ibm-cloud-architecture/cloudnative_sample_app\n        - name: revision\n          default: master\n        - name: image-server\n          default: image-registry.openshift-image-registry.svc:5000\n        - name: image-namespace\n          default: tekton-demo\n        - name: image-repository\n          default: cloudnative_sample_app\n      tasks:\n        - name: test\n          taskRef:\n            name: java-test\n          params:\n            - name: url\n              value: $(params.repo-url)\n            - name: revision\n              value: $(params.revision)\n        - name: build\n          runAfter: [test]\n          taskRef:\n            name: buildah\n          params:\n            - name: image\n              value: $(params.image-server)/$(params.image-namespace)/$(params.image-repository)\n            - name: url\n              value: $(params.repo-url)\n            - name: revision\n              value: $(params.revision)\n    ```\n\n- Pipeline defines a list of Tasks to execute in order, while also indicating if any outputs should be used as inputs of a following Task by using the from field and also indicating the order of executing (using the runAfter and from fields). The same variable substitution you used in Tasks is also available in a Pipeline.\n- Create the Pipeline using the command:\n  ```bash\n  oc apply -f pipeline.yaml -n $NAMESPACE\n  ```\n- Use the Tekton cli to inspect the created resources\n  ```bash\n  tkn pipeline ls -n $NAMESPACE\n  ```\n  The above command should list one Pipeline as shown below:\n  ```bash\n  NAME              AGE              LAST RUN   STARTED   DURATION   STATUS\n  test-build-push   31 seconds ago   ---        ---       ---        ---\n  ```\n\n### PipelineRun\n\n#### PipelineRun Creation\n\n- To execute the Tasks in the Pipeline, you must create a PipelineRun. Creation of a PipelineRun will trigger the creation of TaskRuns for each Task in your pipeline.\n- Create the file **pipelinerun.yaml**\n    ```yaml\n    apiVersion: tekton.dev/v1alpha1\n    kind: PipelineRun\n    metadata:\n      generateName: test-build-run-\n    spec:\n      serviceAccountName: pipeline\n      pipelineRef:\n        name: test-build\n      params:\n        - name: image-server\n          value: image-registry.openshift-image-registry.svc:5000\n        - name: image-namespace\n          value: tekton-demo\n    ```\n    **serviceAccount** - it is always recommended to have a service account associated with PipelineRun, which can then be used to define fine grained roles.\n- Create the PipelineRun using the command:\n    ```bash\n    oc create -f pipelinerun.yaml -n $NAMESPACE\n    ```\n- We will use the Tekton cli to inspect the created resources\n    ```bash\n    tkn pipelinerun ls -n $NAMESPACE\n    ```\n\n- The above command should list one PipelineRun as shown below:\n    ```bash\n    NAME                        STARTED         DURATION   STATUS\n    test-build-push-run-c7zgv   8 seconds ago   ---        Running\n    ```\n\n- Wait for few minutes for your pipeline to complete all the tasks. If it is successful, you will see something like below.\n    ```bash\n    tkn pipeline ls -n $NAMESPACE\n    ```\n    ```\n    NAME              AGE              LAST RUN                    STARTED         DURATION    STATUS\n    test-build-push   33 minutes ago   test-build-push-run-c7zgv   2 minutes ago   2 minutes   Succeeded\n    ```\n- Run again the pipeline ls command\n    ```bash\n    tkn pipelinerun ls -n $NAMESPACE\n    ```\n    ```\n    NAME                        STARTED         DURATION    STATUS\n    test-build-push-run-c7zgv   2 minutes ago   2 minutes   Succeeded\n    ```\n    If it is successful, go to your container registry account and verify if you have the `cloudnative_sample_app` image pushed.\n\n- (Optional) Run the pipeline again using the `tkn` CLI\n    ```bash\n    tkn pipeline start test-build --showlog \\\n      -s pipeline \\\n      -n $NAMESPACE\n    ```\n- (Optional) Re-run the pipeline using last pipelinerun values\n    ```bash\n    tkn pipeline start test-build-push --last -n $NAMESPACE\n    ```\n\n## Deploy Application\n\n- Create a deployment\n  ```bash\n  oc create deployment cloudnative --image=${IMAGE_URL} -n $NAMESPACE\n  ```\n- Verify if the pods are running:\n  ```bash\n  oc get pods -l app=cloudnative -n $NAMESPACE\n  ```\n- Expose the deployment as a service\n  ```bash\n  oc expose deployment cloudnative --port=9080 -n $NAMESPACE\n  ```\n- Expose the service as a route\n  ```bash\n  oc expose service cloudnative -n $NAMESPACE\n  ```\n- Now access the compose the URL of the App using IP and NodePort\n    ```bash\n    export APP_URL=\"$(oc get route cloudnative --template 'http://{{.spec.host}}')/greeting?name=Carlos\"\n    echo APP_URL=$APP_URL\n    ```\n    ```\n    http://cloudnative-tekton-demo.apps-crc.testing/greeting?name=Carlos\n    ```\n- Now access the app from terminal or browser\n    ```bash\n    curl $APP_URL\n    ```\n    Output should be\n    ```json\n    {\"id\":4,\"content\":\"Welcome to Cloudnative bootcamp !!! Hello, Carlos :)\"}\n    ```\n    ```bash\n    open $APP_URL\n    ```\n\n\n</Tab>\n\n<Tab label=\"IKS\">\n\n## SetUp\n\n### Tekton CLI Installation\n\n- [Tekton CLI](https://github.com/tektoncd/cli) is command line utility used to interact with the Tekton resources.\n\n- Follow the instructions on the tekton CLI github repository https://github.com/tektoncd/cli#installing-tkn\n\n- For MacOS for example you can use brew\n    ```bash\n    brew tap tektoncd/tools\n    brew install tektoncd/tools/tektoncd-cli\n    ```\n- Verify the Tekton cli\n    ```bash\n    tkn version\n    ```\n- The command should show a result like:\n    ```bash\n    $ tkn version\n    Client version: 0.10.0\n    ```\n- If you already have the `tkn` install you can upgrade running\n    ```bash\n    brew upgrade tektoncd/tools/tektoncd-cli\n    ```\n\n### Tekton Pipelines Installation\n\n- To deploy the Tekton pipelines:\n    ```bash\n    kubectl apply --filename https://storage.googleapis.com/tekton-releases/pipeline/previous/v0.13.2/release.yaml\n    ```\n- ***Note***: It will take few mins for the Tekton pipeline components to be installed, you an watch the status using the command:\n    ```bash\n    kubectl get pods -n tekton-pipelines -w\n    ```\n    You can use `Ctrl+c` to terminate the watch\n- A successful deployment of Tekton pipelines will show the following pods:\n    ```\n    NAME                                         READY   STATUS    RESTARTS   AGE\n    tekton-pipelines-controller-9b8cccff-j6hvr   1/1     Running   0          2m33s\n    tekton-pipelines-webhook-6fc9d4d9b6-kpkp7    1/1     Running   0          2m33s\n    ```\n\n### Tekton Dashboard Installation (Optional)\n\n- To deploy the Tekton dashboard:\n    ```bash\n    kubectl apply --filename https://github.com/tektoncd/dashboard/releases/download/v0.7.0/tekton-dashboard-release.yaml\n    ```\n- ***Note***: It will take few mins for the Tekton dashboard components to be installed, you an watch the status using the command:\n    ```bash\n    kubectl get pods -n tekton-pipelines -w\n    ```\n    You can use `Ctrl+c` to terminate the watch\n- A successful deployment of Tekton pipelines will show the following pods:\n    ```\n    NAME                                           READY   STATUS    RESTARTS   AGE\n    tekton-dashboard-59c7fbf49f-79f7q              1/1     Running   0          50s\n    tekton-pipelines-controller-6b7f7cf7d8-r65ps   1/1     Running   0          15m\n    tekton-pipelines-webhook-7bbd8fcc45-sfgxs      1/1     Running   0          15m\n    ```\n- Access the dashboard as follows:\n    ```bash\n    kubectl --namespace tekton-pipelines port-forward svc/tekton-dashboard 9097:9097\n    ```\n    You can access the web UI at [http://localhost:9097](http://localhost:9097) .\n\n## Create Target Namespace\n\n- Set the environment variable `NAMESPACE` to `tekton-demo`, if you open a new terminal remember to set this environment again\n    ```bash\n    export NAMESPACE=tekton-demo\n    ```\n- Create a the namespace using the variable `NAMESPACE`\n    ```bash\n    kubectl create namespace $NAMESPACE\n    ```\n\n## Tasks\n\n### Task Creation\n\n- Create the below yaml files.\n- The following snippet shows what a Tekton Task YAML looks like:\n- Create the file **task-test.yaml**\n    ```yaml\n    apiVersion: tekton.dev/v1beta1\n    kind: Task\n    metadata:\n      name: java-test\n    spec:\n      params:\n        - name: url\n        - name: revision\n          default: master\n      steps:\n        - name: git-clone\n          image: alpine/git\n          script: |\n            git clone -b $(params.revision) --depth 1 $(params.url) /source\n          volumeMounts:\n            - name: source\n              mountPath: /source\n        - name: test\n          image: maven:3.3-jdk-8\n          workingdir: /source\n          script: |\n            mvn test\n            echo \"tests passed with rc=$?\"\n          volumeMounts:\n            - name: m2-repository\n              mountPath: /root/.m2\n            - name: source\n              mountPath: /source\n      volumes:\n        - name: m2-repository\n          emptyDir: {}\n        - name: source\n          emptyDir: {}\n    ```\n\n- Each Task has the following:\n- **name** - the unique name using which the task can be referred\n    - name - the name of the parameter\n    - description - the description of the parameter\n    - default - the default value of parameter\n- **Note**: The `TaskRun` or `PipelineRun` could override the parameter values, if no parameter value is passed then the default value will be used.\n\n- **steps** - One or more sub-tasks that will be executed in the defined order. The step has all the attributes like a Pod spec\n- **volumes** - the task can also mount external volumes using the volumes attribute.\n- The parameters that were part of the spec inputs params can be used in the steps using the notation `$(<variable-name>)`.\n\n### Task Deploy\n\n- The application test task could be created using the command:\n    ```bash\n    kubectl apply -f task-test.yaml -n $NAMESPACE\n    ```\n\n- We will use the Tekton cli to inspect the created resources\n    ```bash\n    tkn task ls -n $NAMESPACE\n    ```\n\n- The above command should list one Task as shown below:\n    ```\n    NAME        AGE\n    java-test   22 seconds ago\n    ```\n\n\n### TaskRun\n\n- The [TaskRun](https://github.com/tektoncd/pipeline/blob/master/docs/taskruns.md) is used to run a specific task independently. In the following section we will run the build-app task created in the previous step\n\n#### TaskRun Creation\n\n- The following snippet shows what a Tekton TaskRun YAML looks like:\n- Create the file **taskrun-test.yaml**\n    ```yaml\n    apiVersion: tekton.dev/v1beta1\n    kind: TaskRun\n    metadata:\n      generateName: test-task-run-\n    spec:\n      taskRef:\n        name: java-test\n      params:\n        - name: url\n          value: https://github.com/ibm-cloud-architecture/cloudnative_sample_app\n    ```\n- **generateName** - since the TaskRun can be run many times, in order to have unqiue name across the TaskRun ( helpful when checking the TaskRun history) we use this generateName instead of name. When Kubernetes sees generateName it will generate unquie set of characters and suffix the same to build-app-, similar to how pod names are generated\n- **taskRef** - this is used to refer to the Task by its name that will be run as part of this TaskRun. In this example we use build-app Task.\n- As described in the earlier section that the Task inputs and outputs could be overridden via TaskRun.\n- **params** - this are the parameter values that are passed to the task\n- The application test task(java-maven-test) could be run using the command:\n    ```bash\n    kubectl create -n $NAMESPACE -f taskrun-test.yaml\n    ```\n- **Note** - As tasks will use generated name, never use `kubectl apply -f taskrun-test.yaml`\n- We will use the Tekton cli to inspect the created resources:\n    ```bash\n    tkn tr ls -n $NAMESPACE\n    ```\n    The above command should list one TaskRun as shown below:\n    ```bash\n    NAME                       STARTED        DURATION   STATUS\n    test-task-run-q6s8c        1 minute ago   ---        Running(Pending)\n    ```\n    **Note** - It will take few seconds for the TaskRun to show status as Running as it needs to download the container images.\n\n- To check the logs of the Task Run using the `tkn`:\n  ```bash\n  tkn tr logs -f -a -n $NAMESPACE\n  ```\n  **Note** - Each task step will be run within a container of its own.\n  The -f or -a allows to tail the logs from all the containers of the task. For more options run `tkn tr logs --help`\n- If you see the TaskRun status as Failed or Error use the following command to check the reason for error:\n    ```bash\n    tkn tr describe --last -n $NAMESPACE\n    ```\n- If it is successful, you will see something like below.\n    ```bash\n    tkn tr ls -n $NAMESPACE\n    ```\n    The above command should list one TaskRun as shown below:\n    ```bash\n    NAME                  STARTED          DURATION     STATUS\n    test-task-run-q6s8c   47 seconds ago   34 seconds   Succeeded\n    ```\n\n### Creating additional tasks and deploying them\n\n- Create a Task to build a container image and push to the registry\n- This task will be later used by the pipeline.\n- Download the task file [task-buildah.yaml](/yamls/tekton-lab/task-buildah.yaml) to build the image, push the image to the registy:\n- Create task buildah\n- Create the `buildah` Task using the file and the command:\n    ```bash\n    kubectl apply -f task-buildah.yaml -n $NAMESPACE\n    ```\n- Use the Tekton cli to inspect the created resources\n    ```bash\n    tkn task ls -n $NAMESPACE\n    ```\n- The above command should list one Task as shown below:\n    ```bash\n    NAME              AGE\n    buildah            4 seconds ago\n    java-test         46 minutes ago\n    ```\n\n- To access the container registry, create the required secret as follows.\n- If using IBM Container registry use `iamapikey` for `REGISTRY_USERNAME` and get a API Key for `REGISTRY_PASSWORD`, use the domain name for the region IBM CR service like `us.icr.io`\n- Create the environment variables to be use, replace with real values and include the single quotes:\n    ```bash\n    export REGISTRY_USERNAME='<REGISTRY_USERNAME>'\n    ```\n    ```bash\n    export REGISTRY_PASSWORD='<REGISTRY_PASSWORD>'\n    ```\n    ```bash\n    export REGISTRY_SERVER='docker.io'\n    ```\n\n- Run the following command to create a secret `regcred` in the namespace `NAMESPACE`\n    ```bash\n    kubectl create secret docker-registry regcred \\\n      --docker-server=${REGISTRY_SERVER} \\\n      --docker-username=${REGISTRY_USERNAME} \\\n      --docker-password=${REGISTRY_PASSWORD} \\\n      -n ${NAMESPACE}\n    ```\n\n    <InlineNotification>\n    Before creating, replace the values as mentioned above.\n    Note: If your docker password contains special characters in it, please enclose the password in double quotes or place an escape character before each special character.\n    </InlineNotification>\n\n    - (Optional) Only if you have problems with the credentials you can recreate it, but you have to deleted first\n    ```bash\n    kubectl delete secret regcred -n $NAMESPACE\n    ```\n- Before we run the Task using TaskRun let us create the Kubernetes service account and attach the needed permissions to the service account, the following Kubernetes resource defines a service account called `pipeline` in namespace `$NAMESPACE` who will have administrative role within the `$NAMESPACE` namespace.\n- Create the file **sa.yaml**\n    ```yaml\n    apiVersion: v1\n    kind: ServiceAccount\n    metadata:\n      name: pipeline\n    secrets:\n      - name: regcred\n    ```\n- Create sa role as follows:\n    ```bash\n    kubectl create -n $NAMESPACE -f sa.yaml\n    ```\n\n- Create an environment variable for location to push the image to be build. Replace `NAMESPACE` for the dockerhub username, or IBM CR Namespace\n    ```bash\n    export NAMESPACE='<REGISTRY_NAMESPACE>'\n    export IMAGE_URL=${REGISTRY_SERVER}/${REGISTRY_NAMESPACE}/cloudnative_sample_app\n    ```\n- Lets create a Task Run for `buildah` Task using the `tkn` CLI passing the inputs, outputs and service account.\n    ```bash\n    tkn task start buildah --showlog \\\n      -p url=https://github.com/ibm-cloud-architecture/cloudnative_sample_app \\\n      -p image=${IMAGE_URL} \\\n      -s pipeline \\\n      -n $NAMESPACE\n    ```\n    \n    The task will start and logs will start printing automatically\n    ```\n    Taskrun started: buildah-run-vvrg2\n    Waiting for logs to be available...\n    ```\n\n- Verify the status of the Task Run\n    ```bash\n    tkn tr ls -n $NAMESPACE\n    ```\n    Output should look like this\n    ```bash\n    NAME                  STARTED          DURATION     STATUS\n    buildah-run-zbsrv      2 minutes ago    1 minute     Succeeded\n    ```\n- To clean up all Pods associated with all Task Runs, delete all the task runs resources\n    ```bash\n    kubectl delete taskrun --all -n $NAMESPACE\n    ```\n- (Optional) Instead of starting the Task via `tkn task start` you could also use yaml TaskRun, create a file **taskrun-buildah.yaml** Make sure update value for parameter `image` with your registry info.\n    ```yaml\n    apiVersion: tekton.dev/v1beta1\n    kind: TaskRun\n    metadata:\n      generateName: buildah-task-run-\n    spec:\n      serviceAccountName: pipeline\n      taskRef:\n        name: buildah\n      params:\n        - name: url\n          value: https://github.com/ibm-cloud-architecture/cloudnative_sample_app\n        - name: image\n          value: docker.io/csantanapr/cloudnative_sample_app\n    ```\n    Then create the TaskRun with `generateName`\n    ```bash\n    kubectl create -f taskrun-buildah.yaml -n $NAMESPACE\n    ```\n    Follow the logs with:\n    ```\n    tkn tr logs --last -f -n $NAMESPACE\n    ```\n\n## Pipelines\n\n### Pipeline Creation\n\n- Pipelines allows to start multiple Tasks, in parallel or in a [certain order](https://github.com/tektoncd/pipeline/blob/master/docs/pipelines.md#runafter)\n\n- Create the file **pipeline.yaml**, the Pipeline contains two Tasks\n    ```yaml\n    apiVersion: tekton.dev/v1beta1\n    kind: Pipeline\n    metadata:\n      name: test-build\n    spec:\n      params:\n        - name: repo-url\n          default: https://github.com/ibm-cloud-architecture/cloudnative_sample_app\n        - name: revision\n          default: master\n        - name: image-server\n        - name: image-namespace\n        - name: image-repository\n          default: cloudnative_sample_app\n      tasks:\n        - name: test\n          taskRef:\n            name: java-test\n          params:\n            - name: url\n              value: $(params.repo-url)\n            - name: revision\n              value: $(params.revision)\n        - name: build\n          runAfter: [test]\n          taskRef:\n            name: buildah\n          params:\n            - name: image\n              value: $(params.image-server)/$(params.image-namespace)/$(params.image-repository)\n            - name: url\n              value: $(params.repo-url)\n            - name: revision\n              value: $(params.revision)\n    ```\n\n- Pipeline defines a list of Tasks to execute in order, while also indicating if any outputs should be used as inputs of a following Task by using the from field and also indicating the order of executing (using the runAfter and from fields). The same variable substitution you used in Tasks is also available in a Pipeline.\n- Create the Pipeline using the command:\n  ```bash\n  kubectl apply -f pipeline.yaml -n $NAMESPACE\n  ```\n- Use the Tekton cli to inspect the created resources\n  ```bash\n  tkn pipeline ls -n $NAMESPACE\n  ```\n  The above command should list one Pipeline as shown below:\n  ```bash\n  NAME              AGE              LAST RUN   STARTED   DURATION   STATUS\n  test-build-push   31 seconds ago   ---        ---       ---        ---\n  ```\n\n### PipelineRun\n\n#### PipelineRun Creation\n\n- To execute the Tasks in the Pipeline, you must create a PipelineRun. Creation of a PipelineRun will trigger the creation of TaskRuns for each Task in your pipeline.\n- Create the file **pipelinerun.yaml** replace the values for `image-server` and `image-namespace` with your own.\n    ```yaml\n    apiVersion: tekton.dev/v1beta1\n    kind: PipelineRun\n    metadata:\n      generateName: test-build-run-\n    spec:\n      serviceAccountName: pipeline\n      pipelineRef:\n        name: test-build\n      params:\n        - name: image-server\n          value: us.icr.io\n        - name: image-namespace\n          value: student01-registry\n    ```\n    **serviceAccount** - it is always recommended to have a service account associated with PipelineRun, which can then be used to define fine grained roles.\n    Replace the values for `image-server` and `image-namespace`\n- Create the PipelineRun using the command:\n    ```bash\n    kubectl create -f pipelinerun.yaml -n $NAMESPACE\n    ```\n- We will use the Tekton cli to inspect the created resources\n    ```bash\n    tkn pipelinerun ls -n $NAMESPACE\n    ```\n\n- The above command should list one PipelineRun as shown below:\n    ```bash\n    NAME                        STARTED         DURATION   STATUS\n    test-build-push-run-c7zgv   8 seconds ago   ---        Running\n    ```\n\n- Get the logs of the pipeline using the following command\n    ```bash\n    tkn pipelinerun logs --last -f\n    ```\n- Wait for few minutes for your pipeline to complete all the tasks. If it is successful, you will see something like below.\n    ```bash\n    tkn pipeline ls -n $NAMESPACE\n    ```\n    ```\n    NAME              AGE              LAST RUN                    STARTED         DURATION    STATUS\n    test-build-push   33 minutes ago   test-build-push-run-c7zgv   2 minutes ago   2 minutes   Succeeded\n    ```\n- Run again the pipeline ls command\n    ```bash\n    tkn pipelinerun ls -n $NAMESPACE\n    ```\n    ```\n    NAME                        STARTED         DURATION    STATUS\n    test-build-push-run-c7zgv   2 minutes ago   2 minutes   Succeeded\n    ```\n    If it is successful, go to your container registry account and verify if you have the `cloudnative_sample_app` image pushed.\n\n- (Optional) Run the pipeline again using the `tkn` CLI\n    ```bash\n    tkn pipeline start test-build --last -n $NAMESPACE\n    ```\n- (Optional) Re-run the pipeline using last pipelinerun values\n    ```bash\n    tkn pipeline start test-build-push --last -f -n $NAMESPACE\n    ```\n\n## Deploy Application\n\n- Add the `imagePullSecret` to the `default` Service Account\n  ```bash\n  kubectl patch sa default -p '\"imagePullSecrets\": [{\"name\": \"regcred\" }]' -n $NAMESPACE\n  ```\n- Create a deployment\n  ```bash\n  kubectl create deployment cloudnative --image=${IMAGE_URL} -n $NAMESPACE\n  ```\n- Verify if the pods are running:\n  ```bash\n  kubectl get pods -l app=cloudnative -n $NAMESPACE\n  ```\n- Expose the deployment\n  ```bash\n  kubectl expose deployment cloudnative --type=NodePort --port=9080 -n $NAMESPACE\n  ```\n- Now access the compose the URL of the App using IP and NodePort\n    ```bash\n    export APP_EXTERNAL_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type==\"ExternalIP\")].address}')\n    export APP_NODEPORT=$(kubectl get svc cloudnative -n $NAMESPACE -o jsonpath='{.spec.ports[0].nodePort}')\n    export APP_URL=\"http://${APP_EXTERNAL_IP}:${APP_NODEPORT}/greeting?name=Carlos\"\n    echo APP_URL=$APP_URL\n    ```\n    ```\n    http://192.168.64.30:30632//greeting?name=Carlos\n    ```\n- Now access the app from terminal or browser\n    ```bash\n    curl $APP_URL\n    ```\n    Output should be\n    ```json\n    {\"id\":4,\"content\":\"Welcome to Cloudnative bootcamp !!! Hello, Carlos :)\"}\n    ```\n    ```bash\n    open $APP_URL\n    ```\n\n</Tab>\n\n</Tabs>\n","type":"Mdx","contentDigest":"f4f0396084f1438f031462a32261a66d","counter":587,"owner":"gatsby-plugin-mdx"},"exports":[],"rawBody":"---\ntitle: Tekton Lab\ndescription: Lab for continuous integration using tekton\n---\n\n<AnchorLinks small>\n  <AnchorLink>Prerequisites</AnchorLink>\n  <AnchorLink>SetUp</AnchorLink>\n  <AnchorLink>Create Target Namespace</AnchorLink>\n  <AnchorLink>Tasks</AnchorLink>\n  <AnchorLink>Pipelines</AnchorLink>\n  <AnchorLink>Deploy Application</AnchorLink>\n</AnchorLinks>\n\n## Prerequisites\n\nMake sure your environment is properly setup.\n\nFollow the instructions [here](../../prerequisites#environment-setup)\n<Tabs>\n\n<Tab label=\"OpenShift\">\n\n## SetUp\n\n### Tekton CLI Installation\n\n- [Tekton CLI](https://github.com/tektoncd/cli) is command line utility used to interact with the Tekton resources.\n\n- Follow the instructions on the tekton CLI github repository https://github.com/tektoncd/cli#installing-tkn\n\n- For MacOS for example you can use brew\n    ```\n    brew tap tektoncd/tools\n    brew install tektoncd/tools/tektoncd-cli\n    ```\n- Verify the Tekton cli\n    ```\n    tkn version\n    ```\n- The command should show a result like:\n    ```\n    $ tkn version\n    Client version: 0.10.0\n    ```\n- If you already have the `tkn` install you can upgrade running\n    ```\n    brew upgrade tektoncd/tools/tektoncd-cli\n    ```\n\n### Tekton Pipelines Installation\n\n- To deploy the Tekton pipelines:\n    ```\n   oc apply --filename https://raw.githubusercontent.com/ibm-cloud-architecture/learning-cloudnative-101/master/static/yamls/tekton-lab/tekton-operator.yaml\n    ```\n- ***Note***: It will take few mins for the Tekton pipeline components to be installed, you an watch the status using the command:\n    ```\n    oc get pods -n openshift-operators -w\n    ```\n    You can use `Ctrl+c` to terminate the watch\n- A successful deployment of Tekton pipelines will show the following pods:\n    ```\n    NAME                                         READY   STATUS    RESTARTS   AGE\n    openshift-pipelines-operator-9cdbbb854-x9tvs   1/1     Running   0          25s\n    ```\n\n## Create Target Namespace\n\n- Set the environment variable `NAMESPACE` to `tekton-demo`, if you open a new terminal remember to set this environment again\n    ```\n    export NAMESPACE=tekton-demo\n    ```\n- Create a the namespace using the variable `NAMESPACE`\n    ```\n    oc new-project $NAMESPACE\n    ```\n\n## Tasks\n\n### Task Creation\n\n- Create the below yaml files.\n- The following snippet shows what a Tekton Task YAML looks like:\n- Create the file **task-test.yaml**\n    ```yaml\n    apiVersion: tekton.dev/v1beta1\n    kind: Task\n    metadata:\n      name: java-test\n    spec:\n      params:\n        - name: url\n          default: https://github.com/ibm-cloud-architecture/cloudnative_sample_app\n        - name: revision\n          default: master\n      steps:\n        - name: git-clone\n          image: alpine/git\n          script: |\n            git clone -b $(params.revision) --depth 1 $(params.url) /source\n          volumeMounts:\n            - name: source\n              mountPath: /source\n        - name: test\n          image: maven:3.3-jdk-8\n          workingdir: /source\n          script: |\n            mvn test\n            echo \"tests passed with rc=$?\"\n          volumeMounts:\n            - name: m2-repository\n              mountPath: /root/.m2\n            - name: source\n              mountPath: /source\n      volumes:\n        - name: m2-repository\n          emptyDir: {}\n        - name: source\n          emptyDir: {}\n    ```\n\n- Each Task has the following:\n- **name** - the unique name using which the task can be referred\n    - name - the name of the parameter\n    - description - the description of the parameter\n    - default - the default value of parameter\n- **Note**: The `TaskRun` or `PipelineRun` could override the parameter values, if no parameter value is passed then the default value will be used.\n\n- **steps** - One or more sub-tasks that will be executed in the defined order. The step has all the attributes like a Pod spec\n- **volumes** - the task can also mount external volumes using the volumes attribute.\n- The parameters that were part of the spec inputs params can be used in the steps using the notation `$(<variable-name>)`.\n\n### Task Deploy\n\n- The application test task could be created using the command:\n    ```\n    oc apply -f task-test.yaml -n $NAMESPACE\n    ```\n\n- We will use the Tekton cli to inspect the created resources\n    ```\n    tkn task ls -n $NAMESPACE\n    ```\n\n- The above command should list one Task as shown below:\n    ```\n    NAME        AGE\n    java-test   22 seconds ago\n    ```\n\n\n### TaskRun\n\n- The [TaskRun](https://github.com/tektoncd/pipeline/blob/master/docs/taskruns.md) is used to run a specific task independently. In the following section we will run the build-app task created in the previous step\n\n#### TaskRun Creation\n\n- The following snippet shows what a Tekton TaskRun YAML looks like:\n- Create the file **taskrun-test.yaml**\n    ```yaml\n    apiVersion: tekton.dev/v1beta1\n    kind: TaskRun\n    metadata:\n      generateName: test-task-run-\n    spec:\n      taskRef:\n        name: java-test\n      params:\n        - name: url\n          value: https://github.com/ibm-cloud-architecture/cloudnative_sample_app\n    ```\n- **generateName** - since the TaskRun can be run many times, in order to have unqiue name across the TaskRun ( helpful when checking the TaskRun history) we use this generateName instead of name. When Kubernetes sees generateName it will generate unquie set of characters and suffix the same to build-app-, similar to how pod names are generated\n- **taskRef** - this is used to refer to the Task by its name that will be run as part of this TaskRun. In this example we use build-app Task.\n- As described in the earlier section that the Task inputs and outputs could be overridden via TaskRun.\n- **params** - this are the parameter values that are passed to the task\n- The application test task(java-maven-test) could be run using the command:\n    ```bash\n    kubectl create -f taskrun-test.yaml -n $NAMESPACE \n    ```\n- **Note** - As tasks will use generated name, never use `oc apply -f taskrun-test.yaml`\n- We will use the Tekton cli to inspect the created resources:\n    ```bash\n    tkn tr ls -n $NAMESPACE\n    ```\n    The above command should list one TaskRun as shown below:\n    ```bash\n    NAME                       STARTED        DURATION   STATUS\n    test-task-run-q6s8c        1 minute ago   ---        Running(Pending)\n    ```\n    **Note** - It will take few seconds for the TaskRun to show status as Running as it needs to download the container images.\n\n- To check the logs of the Task Run using the `tkn`:\n  ```bash\n  tkn tr logs -f --last -n $NAMESPACE\n  ```\n  **Note** - Each task step will be run within a container of its own.\n  The -f or -a allows to tail the logs from all the containers of the task. For more options run `tkn tr logs --help`\n- If you see the TaskRun status as Failed or Error use the following command to check the reason for error:\n    ```bash\n    tkn tr describe --last -n $NAMESPACE\n    ```\n- If it is successful, you will see something like below.\n    ```bash\n    tkn tr ls -n $NAMESPACE\n    ```\n    The above command should list one TaskRun as shown below:\n    ```bash\n    NAME                  STARTED          DURATION     STATUS\n    test-task-run   47 seconds ago   34 seconds   Succeeded\n    ```\n\n### Creating additional tasks and deploying them\n\n- Create a Task to build a container image and push to the registry\n- This task will be later used by the pipeline.\n- Download the task file [task-buildah.yaml](/yamls/tekton-lab/task-buildah.yaml) to build the image, push the image to the registy:\n- Create the `buildah` Task using the file and the command:\n    ```\n    oc apply -f task-buildah.yaml -n $NAMESPACE\n    ```\n- Use the Tekton cli to inspect the created resources\n    ```\n    tkn task ls -n $NAMESPACE\n    ```\n- The above command should list one Task as shown below:\n    ```\n    NAME              AGE\n    buildah            4 seconds ago\n    java-test         46 minutes ago\n    ```\n\n\n- Create an environment variable for location to push the image to be build. Replace `NAMESPACE` for the dockerhub username, or IBM CR Namespace\n    ```bash\n    export REGISTRY_SERVER=image-registry.openshift-image-registry.svc:5000\n    export IMAGE_URL=${REGISTRY_SERVER}/${NAMESPACE}/cloudnative_sample_app\n    echo IMAGE_URL=${IMAGE_URL}\n    ```\n- Lets create a Task Run for `buildah` Task using the `tkn` CLI passing the inputs, outputs and service account.\n    ```bash\n    tkn task start buildah --showlog \\\n      -p image=${IMAGE_URL} \\\n      -p url=https://github.com/ibm-cloud-architecture/cloudnative_sample_app \\\n      -s pipeline \\\n      -n $NAMESPACE\n    ```\n    The task will start and logs will start printing automatically\n    ```\n    Taskrun started: buildah-run-vvrg2\n    Waiting for logs to be available...\n    ```\n\n- Verify the status of the Task Run\n    ```bash\n    tkn tr ls -n $NAMESPACE\n    ```\n    Output should look like this\n    ```\n    NAME                  STARTED          DURATION     STATUS\n    buildah-run-zbsrv      2 minutes ago    1 minute     Succeeded\n    ```\n- To clean up all Pods associated with all Task Runs, delete all the task runs resources\n    ```bash\n    oc delete taskrun --all -n $NAMESPACE\n    ```\n- (Optional) Instead of starting the Task via `tkn task start` you could also use yaml TaskRun, create a file **taskrun.yaml**\n    ```yaml\n    apiVersion: tekton.dev/v1beta1\n    kind: TaskRun\n    metadata:\n      generateName: buildah-task-run-\n    spec:\n      serviceAccountName: pipeline\n      taskRef:\n        name: buildah\n      params:\n        - name: url\n          value: https://github.com/ibm-cloud-architecture/cloudnative_sample_app\n        - name: image\n          value: image-registry.openshift-image-registry.svc:5000/tekton-demo/cloudnative_sample_app\n    ```\n    Then create the TaskRun with \n    ```bash\n    oc create -f taskrun-buildah.yaml -n $NAMESPACE\n    ```\n    Follow the logs with:\n    ```\n    tkn tr logs -f -n $NAMESPACE\n    ```\n\n## Pipelines\n\n### Pipeline Creation\n\n- Pipelines allows to start multiple Tasks, in parallel or in a [certain order](https://github.com/tektoncd/pipeline/blob/master/docs/pipelines.md#runafter)\n\n- Create the file **pipeline.yaml**, the Pipeline contains two Tasks\n    ```yaml\n    apiVersion: tekton.dev/v1beta1\n    kind: Pipeline\n    metadata:\n      name: test-build\n    spec:\n      params:\n        - name: repo-url\n          default: https://github.com/ibm-cloud-architecture/cloudnative_sample_app\n        - name: revision\n          default: master\n        - name: image-server\n          default: image-registry.openshift-image-registry.svc:5000\n        - name: image-namespace\n          default: tekton-demo\n        - name: image-repository\n          default: cloudnative_sample_app\n      tasks:\n        - name: test\n          taskRef:\n            name: java-test\n          params:\n            - name: url\n              value: $(params.repo-url)\n            - name: revision\n              value: $(params.revision)\n        - name: build\n          runAfter: [test]\n          taskRef:\n            name: buildah\n          params:\n            - name: image\n              value: $(params.image-server)/$(params.image-namespace)/$(params.image-repository)\n            - name: url\n              value: $(params.repo-url)\n            - name: revision\n              value: $(params.revision)\n    ```\n\n- Pipeline defines a list of Tasks to execute in order, while also indicating if any outputs should be used as inputs of a following Task by using the from field and also indicating the order of executing (using the runAfter and from fields). The same variable substitution you used in Tasks is also available in a Pipeline.\n- Create the Pipeline using the command:\n  ```bash\n  oc apply -f pipeline.yaml -n $NAMESPACE\n  ```\n- Use the Tekton cli to inspect the created resources\n  ```bash\n  tkn pipeline ls -n $NAMESPACE\n  ```\n  The above command should list one Pipeline as shown below:\n  ```bash\n  NAME              AGE              LAST RUN   STARTED   DURATION   STATUS\n  test-build-push   31 seconds ago   ---        ---       ---        ---\n  ```\n\n### PipelineRun\n\n#### PipelineRun Creation\n\n- To execute the Tasks in the Pipeline, you must create a PipelineRun. Creation of a PipelineRun will trigger the creation of TaskRuns for each Task in your pipeline.\n- Create the file **pipelinerun.yaml**\n    ```yaml\n    apiVersion: tekton.dev/v1alpha1\n    kind: PipelineRun\n    metadata:\n      generateName: test-build-run-\n    spec:\n      serviceAccountName: pipeline\n      pipelineRef:\n        name: test-build\n      params:\n        - name: image-server\n          value: image-registry.openshift-image-registry.svc:5000\n        - name: image-namespace\n          value: tekton-demo\n    ```\n    **serviceAccount** - it is always recommended to have a service account associated with PipelineRun, which can then be used to define fine grained roles.\n- Create the PipelineRun using the command:\n    ```bash\n    oc create -f pipelinerun.yaml -n $NAMESPACE\n    ```\n- We will use the Tekton cli to inspect the created resources\n    ```bash\n    tkn pipelinerun ls -n $NAMESPACE\n    ```\n\n- The above command should list one PipelineRun as shown below:\n    ```bash\n    NAME                        STARTED         DURATION   STATUS\n    test-build-push-run-c7zgv   8 seconds ago   ---        Running\n    ```\n\n- Wait for few minutes for your pipeline to complete all the tasks. If it is successful, you will see something like below.\n    ```bash\n    tkn pipeline ls -n $NAMESPACE\n    ```\n    ```\n    NAME              AGE              LAST RUN                    STARTED         DURATION    STATUS\n    test-build-push   33 minutes ago   test-build-push-run-c7zgv   2 minutes ago   2 minutes   Succeeded\n    ```\n- Run again the pipeline ls command\n    ```bash\n    tkn pipelinerun ls -n $NAMESPACE\n    ```\n    ```\n    NAME                        STARTED         DURATION    STATUS\n    test-build-push-run-c7zgv   2 minutes ago   2 minutes   Succeeded\n    ```\n    If it is successful, go to your container registry account and verify if you have the `cloudnative_sample_app` image pushed.\n\n- (Optional) Run the pipeline again using the `tkn` CLI\n    ```bash\n    tkn pipeline start test-build --showlog \\\n      -s pipeline \\\n      -n $NAMESPACE\n    ```\n- (Optional) Re-run the pipeline using last pipelinerun values\n    ```bash\n    tkn pipeline start test-build-push --last -n $NAMESPACE\n    ```\n\n## Deploy Application\n\n- Create a deployment\n  ```bash\n  oc create deployment cloudnative --image=${IMAGE_URL} -n $NAMESPACE\n  ```\n- Verify if the pods are running:\n  ```bash\n  oc get pods -l app=cloudnative -n $NAMESPACE\n  ```\n- Expose the deployment as a service\n  ```bash\n  oc expose deployment cloudnative --port=9080 -n $NAMESPACE\n  ```\n- Expose the service as a route\n  ```bash\n  oc expose service cloudnative -n $NAMESPACE\n  ```\n- Now access the compose the URL of the App using IP and NodePort\n    ```bash\n    export APP_URL=\"$(oc get route cloudnative --template 'http://{{.spec.host}}')/greeting?name=Carlos\"\n    echo APP_URL=$APP_URL\n    ```\n    ```\n    http://cloudnative-tekton-demo.apps-crc.testing/greeting?name=Carlos\n    ```\n- Now access the app from terminal or browser\n    ```bash\n    curl $APP_URL\n    ```\n    Output should be\n    ```json\n    {\"id\":4,\"content\":\"Welcome to Cloudnative bootcamp !!! Hello, Carlos :)\"}\n    ```\n    ```bash\n    open $APP_URL\n    ```\n\n\n</Tab>\n\n<Tab label=\"IKS\">\n\n## SetUp\n\n### Tekton CLI Installation\n\n- [Tekton CLI](https://github.com/tektoncd/cli) is command line utility used to interact with the Tekton resources.\n\n- Follow the instructions on the tekton CLI github repository https://github.com/tektoncd/cli#installing-tkn\n\n- For MacOS for example you can use brew\n    ```bash\n    brew tap tektoncd/tools\n    brew install tektoncd/tools/tektoncd-cli\n    ```\n- Verify the Tekton cli\n    ```bash\n    tkn version\n    ```\n- The command should show a result like:\n    ```bash\n    $ tkn version\n    Client version: 0.10.0\n    ```\n- If you already have the `tkn` install you can upgrade running\n    ```bash\n    brew upgrade tektoncd/tools/tektoncd-cli\n    ```\n\n### Tekton Pipelines Installation\n\n- To deploy the Tekton pipelines:\n    ```bash\n    kubectl apply --filename https://storage.googleapis.com/tekton-releases/pipeline/previous/v0.13.2/release.yaml\n    ```\n- ***Note***: It will take few mins for the Tekton pipeline components to be installed, you an watch the status using the command:\n    ```bash\n    kubectl get pods -n tekton-pipelines -w\n    ```\n    You can use `Ctrl+c` to terminate the watch\n- A successful deployment of Tekton pipelines will show the following pods:\n    ```\n    NAME                                         READY   STATUS    RESTARTS   AGE\n    tekton-pipelines-controller-9b8cccff-j6hvr   1/1     Running   0          2m33s\n    tekton-pipelines-webhook-6fc9d4d9b6-kpkp7    1/1     Running   0          2m33s\n    ```\n\n### Tekton Dashboard Installation (Optional)\n\n- To deploy the Tekton dashboard:\n    ```bash\n    kubectl apply --filename https://github.com/tektoncd/dashboard/releases/download/v0.7.0/tekton-dashboard-release.yaml\n    ```\n- ***Note***: It will take few mins for the Tekton dashboard components to be installed, you an watch the status using the command:\n    ```bash\n    kubectl get pods -n tekton-pipelines -w\n    ```\n    You can use `Ctrl+c` to terminate the watch\n- A successful deployment of Tekton pipelines will show the following pods:\n    ```\n    NAME                                           READY   STATUS    RESTARTS   AGE\n    tekton-dashboard-59c7fbf49f-79f7q              1/1     Running   0          50s\n    tekton-pipelines-controller-6b7f7cf7d8-r65ps   1/1     Running   0          15m\n    tekton-pipelines-webhook-7bbd8fcc45-sfgxs      1/1     Running   0          15m\n    ```\n- Access the dashboard as follows:\n    ```bash\n    kubectl --namespace tekton-pipelines port-forward svc/tekton-dashboard 9097:9097\n    ```\n    You can access the web UI at [http://localhost:9097](http://localhost:9097) .\n\n## Create Target Namespace\n\n- Set the environment variable `NAMESPACE` to `tekton-demo`, if you open a new terminal remember to set this environment again\n    ```bash\n    export NAMESPACE=tekton-demo\n    ```\n- Create a the namespace using the variable `NAMESPACE`\n    ```bash\n    kubectl create namespace $NAMESPACE\n    ```\n\n## Tasks\n\n### Task Creation\n\n- Create the below yaml files.\n- The following snippet shows what a Tekton Task YAML looks like:\n- Create the file **task-test.yaml**\n    ```yaml\n    apiVersion: tekton.dev/v1beta1\n    kind: Task\n    metadata:\n      name: java-test\n    spec:\n      params:\n        - name: url\n        - name: revision\n          default: master\n      steps:\n        - name: git-clone\n          image: alpine/git\n          script: |\n            git clone -b $(params.revision) --depth 1 $(params.url) /source\n          volumeMounts:\n            - name: source\n              mountPath: /source\n        - name: test\n          image: maven:3.3-jdk-8\n          workingdir: /source\n          script: |\n            mvn test\n            echo \"tests passed with rc=$?\"\n          volumeMounts:\n            - name: m2-repository\n              mountPath: /root/.m2\n            - name: source\n              mountPath: /source\n      volumes:\n        - name: m2-repository\n          emptyDir: {}\n        - name: source\n          emptyDir: {}\n    ```\n\n- Each Task has the following:\n- **name** - the unique name using which the task can be referred\n    - name - the name of the parameter\n    - description - the description of the parameter\n    - default - the default value of parameter\n- **Note**: The `TaskRun` or `PipelineRun` could override the parameter values, if no parameter value is passed then the default value will be used.\n\n- **steps** - One or more sub-tasks that will be executed in the defined order. The step has all the attributes like a Pod spec\n- **volumes** - the task can also mount external volumes using the volumes attribute.\n- The parameters that were part of the spec inputs params can be used in the steps using the notation `$(<variable-name>)`.\n\n### Task Deploy\n\n- The application test task could be created using the command:\n    ```bash\n    kubectl apply -f task-test.yaml -n $NAMESPACE\n    ```\n\n- We will use the Tekton cli to inspect the created resources\n    ```bash\n    tkn task ls -n $NAMESPACE\n    ```\n\n- The above command should list one Task as shown below:\n    ```\n    NAME        AGE\n    java-test   22 seconds ago\n    ```\n\n\n### TaskRun\n\n- The [TaskRun](https://github.com/tektoncd/pipeline/blob/master/docs/taskruns.md) is used to run a specific task independently. In the following section we will run the build-app task created in the previous step\n\n#### TaskRun Creation\n\n- The following snippet shows what a Tekton TaskRun YAML looks like:\n- Create the file **taskrun-test.yaml**\n    ```yaml\n    apiVersion: tekton.dev/v1beta1\n    kind: TaskRun\n    metadata:\n      generateName: test-task-run-\n    spec:\n      taskRef:\n        name: java-test\n      params:\n        - name: url\n          value: https://github.com/ibm-cloud-architecture/cloudnative_sample_app\n    ```\n- **generateName** - since the TaskRun can be run many times, in order to have unqiue name across the TaskRun ( helpful when checking the TaskRun history) we use this generateName instead of name. When Kubernetes sees generateName it will generate unquie set of characters and suffix the same to build-app-, similar to how pod names are generated\n- **taskRef** - this is used to refer to the Task by its name that will be run as part of this TaskRun. In this example we use build-app Task.\n- As described in the earlier section that the Task inputs and outputs could be overridden via TaskRun.\n- **params** - this are the parameter values that are passed to the task\n- The application test task(java-maven-test) could be run using the command:\n    ```bash\n    kubectl create -n $NAMESPACE -f taskrun-test.yaml\n    ```\n- **Note** - As tasks will use generated name, never use `kubectl apply -f taskrun-test.yaml`\n- We will use the Tekton cli to inspect the created resources:\n    ```bash\n    tkn tr ls -n $NAMESPACE\n    ```\n    The above command should list one TaskRun as shown below:\n    ```bash\n    NAME                       STARTED        DURATION   STATUS\n    test-task-run-q6s8c        1 minute ago   ---        Running(Pending)\n    ```\n    **Note** - It will take few seconds for the TaskRun to show status as Running as it needs to download the container images.\n\n- To check the logs of the Task Run using the `tkn`:\n  ```bash\n  tkn tr logs -f -a -n $NAMESPACE\n  ```\n  **Note** - Each task step will be run within a container of its own.\n  The -f or -a allows to tail the logs from all the containers of the task. For more options run `tkn tr logs --help`\n- If you see the TaskRun status as Failed or Error use the following command to check the reason for error:\n    ```bash\n    tkn tr describe --last -n $NAMESPACE\n    ```\n- If it is successful, you will see something like below.\n    ```bash\n    tkn tr ls -n $NAMESPACE\n    ```\n    The above command should list one TaskRun as shown below:\n    ```bash\n    NAME                  STARTED          DURATION     STATUS\n    test-task-run-q6s8c   47 seconds ago   34 seconds   Succeeded\n    ```\n\n### Creating additional tasks and deploying them\n\n- Create a Task to build a container image and push to the registry\n- This task will be later used by the pipeline.\n- Download the task file [task-buildah.yaml](/yamls/tekton-lab/task-buildah.yaml) to build the image, push the image to the registy:\n- Create task buildah\n- Create the `buildah` Task using the file and the command:\n    ```bash\n    kubectl apply -f task-buildah.yaml -n $NAMESPACE\n    ```\n- Use the Tekton cli to inspect the created resources\n    ```bash\n    tkn task ls -n $NAMESPACE\n    ```\n- The above command should list one Task as shown below:\n    ```bash\n    NAME              AGE\n    buildah            4 seconds ago\n    java-test         46 minutes ago\n    ```\n\n- To access the container registry, create the required secret as follows.\n- If using IBM Container registry use `iamapikey` for `REGISTRY_USERNAME` and get a API Key for `REGISTRY_PASSWORD`, use the domain name for the region IBM CR service like `us.icr.io`\n- Create the environment variables to be use, replace with real values and include the single quotes:\n    ```bash\n    export REGISTRY_USERNAME='<REGISTRY_USERNAME>'\n    ```\n    ```bash\n    export REGISTRY_PASSWORD='<REGISTRY_PASSWORD>'\n    ```\n    ```bash\n    export REGISTRY_SERVER='docker.io'\n    ```\n\n- Run the following command to create a secret `regcred` in the namespace `NAMESPACE`\n    ```bash\n    kubectl create secret docker-registry regcred \\\n      --docker-server=${REGISTRY_SERVER} \\\n      --docker-username=${REGISTRY_USERNAME} \\\n      --docker-password=${REGISTRY_PASSWORD} \\\n      -n ${NAMESPACE}\n    ```\n\n    <InlineNotification>\n    Before creating, replace the values as mentioned above.\n    Note: If your docker password contains special characters in it, please enclose the password in double quotes or place an escape character before each special character.\n    </InlineNotification>\n\n    - (Optional) Only if you have problems with the credentials you can recreate it, but you have to deleted first\n    ```bash\n    kubectl delete secret regcred -n $NAMESPACE\n    ```\n- Before we run the Task using TaskRun let us create the Kubernetes service account and attach the needed permissions to the service account, the following Kubernetes resource defines a service account called `pipeline` in namespace `$NAMESPACE` who will have administrative role within the `$NAMESPACE` namespace.\n- Create the file **sa.yaml**\n    ```yaml\n    apiVersion: v1\n    kind: ServiceAccount\n    metadata:\n      name: pipeline\n    secrets:\n      - name: regcred\n    ```\n- Create sa role as follows:\n    ```bash\n    kubectl create -n $NAMESPACE -f sa.yaml\n    ```\n\n- Create an environment variable for location to push the image to be build. Replace `NAMESPACE` for the dockerhub username, or IBM CR Namespace\n    ```bash\n    export NAMESPACE='<REGISTRY_NAMESPACE>'\n    export IMAGE_URL=${REGISTRY_SERVER}/${REGISTRY_NAMESPACE}/cloudnative_sample_app\n    ```\n- Lets create a Task Run for `buildah` Task using the `tkn` CLI passing the inputs, outputs and service account.\n    ```bash\n    tkn task start buildah --showlog \\\n      -p url=https://github.com/ibm-cloud-architecture/cloudnative_sample_app \\\n      -p image=${IMAGE_URL} \\\n      -s pipeline \\\n      -n $NAMESPACE\n    ```\n    \n    The task will start and logs will start printing automatically\n    ```\n    Taskrun started: buildah-run-vvrg2\n    Waiting for logs to be available...\n    ```\n\n- Verify the status of the Task Run\n    ```bash\n    tkn tr ls -n $NAMESPACE\n    ```\n    Output should look like this\n    ```bash\n    NAME                  STARTED          DURATION     STATUS\n    buildah-run-zbsrv      2 minutes ago    1 minute     Succeeded\n    ```\n- To clean up all Pods associated with all Task Runs, delete all the task runs resources\n    ```bash\n    kubectl delete taskrun --all -n $NAMESPACE\n    ```\n- (Optional) Instead of starting the Task via `tkn task start` you could also use yaml TaskRun, create a file **taskrun-buildah.yaml** Make sure update value for parameter `image` with your registry info.\n    ```yaml\n    apiVersion: tekton.dev/v1beta1\n    kind: TaskRun\n    metadata:\n      generateName: buildah-task-run-\n    spec:\n      serviceAccountName: pipeline\n      taskRef:\n        name: buildah\n      params:\n        - name: url\n          value: https://github.com/ibm-cloud-architecture/cloudnative_sample_app\n        - name: image\n          value: docker.io/csantanapr/cloudnative_sample_app\n    ```\n    Then create the TaskRun with `generateName`\n    ```bash\n    kubectl create -f taskrun-buildah.yaml -n $NAMESPACE\n    ```\n    Follow the logs with:\n    ```\n    tkn tr logs --last -f -n $NAMESPACE\n    ```\n\n## Pipelines\n\n### Pipeline Creation\n\n- Pipelines allows to start multiple Tasks, in parallel or in a [certain order](https://github.com/tektoncd/pipeline/blob/master/docs/pipelines.md#runafter)\n\n- Create the file **pipeline.yaml**, the Pipeline contains two Tasks\n    ```yaml\n    apiVersion: tekton.dev/v1beta1\n    kind: Pipeline\n    metadata:\n      name: test-build\n    spec:\n      params:\n        - name: repo-url\n          default: https://github.com/ibm-cloud-architecture/cloudnative_sample_app\n        - name: revision\n          default: master\n        - name: image-server\n        - name: image-namespace\n        - name: image-repository\n          default: cloudnative_sample_app\n      tasks:\n        - name: test\n          taskRef:\n            name: java-test\n          params:\n            - name: url\n              value: $(params.repo-url)\n            - name: revision\n              value: $(params.revision)\n        - name: build\n          runAfter: [test]\n          taskRef:\n            name: buildah\n          params:\n            - name: image\n              value: $(params.image-server)/$(params.image-namespace)/$(params.image-repository)\n            - name: url\n              value: $(params.repo-url)\n            - name: revision\n              value: $(params.revision)\n    ```\n\n- Pipeline defines a list of Tasks to execute in order, while also indicating if any outputs should be used as inputs of a following Task by using the from field and also indicating the order of executing (using the runAfter and from fields). The same variable substitution you used in Tasks is also available in a Pipeline.\n- Create the Pipeline using the command:\n  ```bash\n  kubectl apply -f pipeline.yaml -n $NAMESPACE\n  ```\n- Use the Tekton cli to inspect the created resources\n  ```bash\n  tkn pipeline ls -n $NAMESPACE\n  ```\n  The above command should list one Pipeline as shown below:\n  ```bash\n  NAME              AGE              LAST RUN   STARTED   DURATION   STATUS\n  test-build-push   31 seconds ago   ---        ---       ---        ---\n  ```\n\n### PipelineRun\n\n#### PipelineRun Creation\n\n- To execute the Tasks in the Pipeline, you must create a PipelineRun. Creation of a PipelineRun will trigger the creation of TaskRuns for each Task in your pipeline.\n- Create the file **pipelinerun.yaml** replace the values for `image-server` and `image-namespace` with your own.\n    ```yaml\n    apiVersion: tekton.dev/v1beta1\n    kind: PipelineRun\n    metadata:\n      generateName: test-build-run-\n    spec:\n      serviceAccountName: pipeline\n      pipelineRef:\n        name: test-build\n      params:\n        - name: image-server\n          value: us.icr.io\n        - name: image-namespace\n          value: student01-registry\n    ```\n    **serviceAccount** - it is always recommended to have a service account associated with PipelineRun, which can then be used to define fine grained roles.\n    Replace the values for `image-server` and `image-namespace`\n- Create the PipelineRun using the command:\n    ```bash\n    kubectl create -f pipelinerun.yaml -n $NAMESPACE\n    ```\n- We will use the Tekton cli to inspect the created resources\n    ```bash\n    tkn pipelinerun ls -n $NAMESPACE\n    ```\n\n- The above command should list one PipelineRun as shown below:\n    ```bash\n    NAME                        STARTED         DURATION   STATUS\n    test-build-push-run-c7zgv   8 seconds ago   ---        Running\n    ```\n\n- Get the logs of the pipeline using the following command\n    ```bash\n    tkn pipelinerun logs --last -f\n    ```\n- Wait for few minutes for your pipeline to complete all the tasks. If it is successful, you will see something like below.\n    ```bash\n    tkn pipeline ls -n $NAMESPACE\n    ```\n    ```\n    NAME              AGE              LAST RUN                    STARTED         DURATION    STATUS\n    test-build-push   33 minutes ago   test-build-push-run-c7zgv   2 minutes ago   2 minutes   Succeeded\n    ```\n- Run again the pipeline ls command\n    ```bash\n    tkn pipelinerun ls -n $NAMESPACE\n    ```\n    ```\n    NAME                        STARTED         DURATION    STATUS\n    test-build-push-run-c7zgv   2 minutes ago   2 minutes   Succeeded\n    ```\n    If it is successful, go to your container registry account and verify if you have the `cloudnative_sample_app` image pushed.\n\n- (Optional) Run the pipeline again using the `tkn` CLI\n    ```bash\n    tkn pipeline start test-build --last -n $NAMESPACE\n    ```\n- (Optional) Re-run the pipeline using last pipelinerun values\n    ```bash\n    tkn pipeline start test-build-push --last -f -n $NAMESPACE\n    ```\n\n## Deploy Application\n\n- Add the `imagePullSecret` to the `default` Service Account\n  ```bash\n  kubectl patch sa default -p '\"imagePullSecrets\": [{\"name\": \"regcred\" }]' -n $NAMESPACE\n  ```\n- Create a deployment\n  ```bash\n  kubectl create deployment cloudnative --image=${IMAGE_URL} -n $NAMESPACE\n  ```\n- Verify if the pods are running:\n  ```bash\n  kubectl get pods -l app=cloudnative -n $NAMESPACE\n  ```\n- Expose the deployment\n  ```bash\n  kubectl expose deployment cloudnative --type=NodePort --port=9080 -n $NAMESPACE\n  ```\n- Now access the compose the URL of the App using IP and NodePort\n    ```bash\n    export APP_EXTERNAL_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type==\"ExternalIP\")].address}')\n    export APP_NODEPORT=$(kubectl get svc cloudnative -n $NAMESPACE -o jsonpath='{.spec.ports[0].nodePort}')\n    export APP_URL=\"http://${APP_EXTERNAL_IP}:${APP_NODEPORT}/greeting?name=Carlos\"\n    echo APP_URL=$APP_URL\n    ```\n    ```\n    http://192.168.64.30:30632//greeting?name=Carlos\n    ```\n- Now access the app from terminal or browser\n    ```bash\n    curl $APP_URL\n    ```\n    Output should be\n    ```json\n    {\"id\":4,\"content\":\"Welcome to Cloudnative bootcamp !!! Hello, Carlos :)\"}\n    ```\n    ```bash\n    open $APP_URL\n    ```\n\n</Tab>\n\n</Tabs>\n","frontmatter":{"title":"Tekton Lab","description":"Lab for continuous integration using tekton"},"fileAbsolutePath":"/home/travis/build/ibm-cloud-architecture/learning-cloudnative-101/src/pages/lectures/continuous-integration/activities/index.mdx"}}},"staticQueryHashes":["1364590287","2102389209","2102389209","2456312558","2746626797","2746626797","3018647132","3018647132","3037994772","3037994772","63531786","63531786","768070550"]}