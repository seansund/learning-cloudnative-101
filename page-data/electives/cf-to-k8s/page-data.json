{"componentChunkName":"component---src-pages-electives-cf-to-k-8-s-index-mdx","path":"/electives/cf-to-k8s/","result":{"pageContext":{"frontmatter":{"title":"Kubernetes for CloudFoundry users","description":"Cloud Foundry to Kubernetes"},"relativePagePath":"/electives/cf-to-k8s/index.mdx","titleType":"page","MdxNode":{"id":"e1c4d896-8cca-5cb7-b5db-6ccaf03dfc4d","children":[],"parent":"537bf37b-754c-5962-84a4-dcac4b5bb2e7","internal":{"content":"---\ntitle: Kubernetes for CloudFoundry users\ndescription: Cloud Foundry to Kubernetes\n---\n\n## Overview\n\nProvided that you have been working mainly with CloudFoundry based application and had just learned on what Kubernetes is, this module tries to bridge the concept of what is happening in Kubernetes world that would correspond to the familiar thing in CloudFoundry application. This module assumes that you are very familar with CloudFoundry and have some basic understanding of Kubernetes objects and resources.\n\nThe discussion in this module comes in two sub-sections:\n\n- Application execution environment comparison for CloudFoundry and Kubernetes and OpenShift\n- Application staging process comparison for CloudFoundry\n\n## Application execution environment\n\nThe application execution environment diagram for CloudFoundry below demonstrates the components that runs CloudFoundry applications.\n\n<img src=\"./images/cf.PNG\" alt=\"cf\"></img>\n\nIn CloudFoundry, application runs within a Diego cell (used to be a DEA node) which runs a Garden container.\nThe cell is constructed from Droplet image that is stored in CloudFoundry BLOB store.\nCloudFoundry provides router (Go router) for accessing the application running in the cell so that external access is enabled for the application.\nFor the application to access the backend services, it facilitates an environment variable called VCAP_SERVICES, which contains the credentials and access information for those backend services.\n\nIn Kubernetes application runs in the Kubernetes cluster as demonstrated below:\n\n<img src=\"./images/kube.PNG\" alt=\"Kube\"></img>\n\n- Kubernetes applications run in Pods, which are similar to Cloud Foundry Diego cells.\n- There is a Kubernetes Service that performs load balancing for all the pod instances.\n- External access to the Service is received from either a NodePort, a LoadBalancer service or an Ingress entry.\n- The combination of Kubernetes Service and Ingress entry serves a similar function to the Go Router in CloudFoundry.\n- Backend services binding in Kubernetes must be defined by the developer, the system does not provide a binding.\n- Typically the information on where the service is located can be found in ConfigMaps and the credentials to access the service is stored in Secrets.\n- So you can ended up with multiple configurations that are provided by the backend environment that you must bind to each of the applications that uses them.\n- These ConfigMaps and Secrets are comparable to CloudFoundry's provided VCAP_SERVICES environment variable.\n\nFor OpenShift, which is derived from Kubernetes, the architecture is very similar. However, OpenShift has provided some functionality for the cluster that allows a more simple configuration of a cluster.\n\n- One of the example is OpenShift router, which provides a combined way to develop an Ingress entry with a setting of DNS resources, this function is very similar to CloudFoundry Go Router.\n- OpenShift uses a DeploymentConfig, which has more capabilities than a Kubernetes Deployment, it supports the definition of triggers, which allow the pods to be modified when a certain situation (such as image or configuration is updated).\n\n<img src=\"./images/oc.PNG\" alt=\"oc\"></img>\n\n## Application Staging\n\nThe staging of application, from the source repository into a runnable image differs greatly from one platform to another.\nThe staging is performed after the build artifact is collected, this include performing maven, gradle or other build mechanism.\nApplication is then staged into the Cloud platform; this staging process is typically split into: application container image creation and application container deployment.\n\n<img src=\"./images/staging.PNG\" alt=\"staging\"></img>\n\nIn CloudFoundry, Droplet images are built by the CloudFoundry buildpacks.\n\n- The buildpack will evaluate the application artifacts and construct a runnable Droplet image by providing the necessary pre-requisites and collect dependent codes.\n- This process is explained further in [CloudFoundry staging](https://docs.cloudfoundry.org/concepts/how-applications-are-staged.html).\n- The runnable Droplet image is stored in BLOB store and then to be deployed as a Garden container in a Diego cell.\n- The service binding is provided by CloudFoundry as VCAP_SERVICES environment variable in the container.\n- Finally CloudFoundry defines a Router entry for the application.\n\nAlthough these processes sound complicated, it is actually performed using a single command `cf push`.\n\nIn OpenShift the staging of application is perfomed using BuildConfig, DeploymentConfig and bindings are defined in ConfigMaps and Secrets.\n\n- OpenShift is using a **BuildConfig** generates an **ImageStream** in OpenShift.\n- ImageStream represent a container image which can be build using Dockerfile or S2I process.\n- The image building part can be accomplished using the command:\n\n```bash\n oc start-build (buildconfig_name)\n```\n\n- You or the backend service provider then create ConfigMap and Secrets to access backend services.\n- Finally, you use a Template object that contains at least a **DeploymentConfig** (with **Pod** definition), **Service** and **Route** to deploy the application.\n- You deploy the application using the command:\n\n```bash\n oc new-app -f template.yaml\n```\nIn Kubernetes, staging is performed as follows:\n\n- You create a **docker image** using a Dockerfile and store the image in a **Docker repository**\n```bash\n docker build -t (image)\n docker push (image)\n```\n- You create ConfigMap and Secrets to access backend services\n- You use YAML file to deploy Kubernetes resources such as **Kubernetes Pod** in a Deployment, **Kubernetes Service** and maybe an **Ingress**\n```bash\n kubectl apply -f (template)\n```\n\n## Activities\n\n| Task                            | Description         | Link        |\n| --------------------------------| ------------------  |:----------- |\n| *** Try It Yourself ***                         |         |         |\n| Migrating to IKS | Migrating from Cloud Foundry to IKS | [IKS](../cf-to-k8s/iks-migration/) |\n| Migrating to OpenShift | Migrating from Cloud Foundry to OpenShift | [OCP](../cf-to-k8s/oc-migration/) |","type":"Mdx","contentDigest":"984a3ae1cc663fd3667da5ccf26ce9cb","counter":558,"owner":"gatsby-plugin-mdx"},"exports":[],"rawBody":"---\ntitle: Kubernetes for CloudFoundry users\ndescription: Cloud Foundry to Kubernetes\n---\n\n## Overview\n\nProvided that you have been working mainly with CloudFoundry based application and had just learned on what Kubernetes is, this module tries to bridge the concept of what is happening in Kubernetes world that would correspond to the familiar thing in CloudFoundry application. This module assumes that you are very familar with CloudFoundry and have some basic understanding of Kubernetes objects and resources.\n\nThe discussion in this module comes in two sub-sections:\n\n- Application execution environment comparison for CloudFoundry and Kubernetes and OpenShift\n- Application staging process comparison for CloudFoundry\n\n## Application execution environment\n\nThe application execution environment diagram for CloudFoundry below demonstrates the components that runs CloudFoundry applications.\n\n<img src=\"./images/cf.PNG\" alt=\"cf\"></img>\n\nIn CloudFoundry, application runs within a Diego cell (used to be a DEA node) which runs a Garden container.\nThe cell is constructed from Droplet image that is stored in CloudFoundry BLOB store.\nCloudFoundry provides router (Go router) for accessing the application running in the cell so that external access is enabled for the application.\nFor the application to access the backend services, it facilitates an environment variable called VCAP_SERVICES, which contains the credentials and access information for those backend services.\n\nIn Kubernetes application runs in the Kubernetes cluster as demonstrated below:\n\n<img src=\"./images/kube.PNG\" alt=\"Kube\"></img>\n\n- Kubernetes applications run in Pods, which are similar to Cloud Foundry Diego cells.\n- There is a Kubernetes Service that performs load balancing for all the pod instances.\n- External access to the Service is received from either a NodePort, a LoadBalancer service or an Ingress entry.\n- The combination of Kubernetes Service and Ingress entry serves a similar function to the Go Router in CloudFoundry.\n- Backend services binding in Kubernetes must be defined by the developer, the system does not provide a binding.\n- Typically the information on where the service is located can be found in ConfigMaps and the credentials to access the service is stored in Secrets.\n- So you can ended up with multiple configurations that are provided by the backend environment that you must bind to each of the applications that uses them.\n- These ConfigMaps and Secrets are comparable to CloudFoundry's provided VCAP_SERVICES environment variable.\n\nFor OpenShift, which is derived from Kubernetes, the architecture is very similar. However, OpenShift has provided some functionality for the cluster that allows a more simple configuration of a cluster.\n\n- One of the example is OpenShift router, which provides a combined way to develop an Ingress entry with a setting of DNS resources, this function is very similar to CloudFoundry Go Router.\n- OpenShift uses a DeploymentConfig, which has more capabilities than a Kubernetes Deployment, it supports the definition of triggers, which allow the pods to be modified when a certain situation (such as image or configuration is updated).\n\n<img src=\"./images/oc.PNG\" alt=\"oc\"></img>\n\n## Application Staging\n\nThe staging of application, from the source repository into a runnable image differs greatly from one platform to another.\nThe staging is performed after the build artifact is collected, this include performing maven, gradle or other build mechanism.\nApplication is then staged into the Cloud platform; this staging process is typically split into: application container image creation and application container deployment.\n\n<img src=\"./images/staging.PNG\" alt=\"staging\"></img>\n\nIn CloudFoundry, Droplet images are built by the CloudFoundry buildpacks.\n\n- The buildpack will evaluate the application artifacts and construct a runnable Droplet image by providing the necessary pre-requisites and collect dependent codes.\n- This process is explained further in [CloudFoundry staging](https://docs.cloudfoundry.org/concepts/how-applications-are-staged.html).\n- The runnable Droplet image is stored in BLOB store and then to be deployed as a Garden container in a Diego cell.\n- The service binding is provided by CloudFoundry as VCAP_SERVICES environment variable in the container.\n- Finally CloudFoundry defines a Router entry for the application.\n\nAlthough these processes sound complicated, it is actually performed using a single command `cf push`.\n\nIn OpenShift the staging of application is perfomed using BuildConfig, DeploymentConfig and bindings are defined in ConfigMaps and Secrets.\n\n- OpenShift is using a **BuildConfig** generates an **ImageStream** in OpenShift.\n- ImageStream represent a container image which can be build using Dockerfile or S2I process.\n- The image building part can be accomplished using the command:\n\n```bash\n oc start-build (buildconfig_name)\n```\n\n- You or the backend service provider then create ConfigMap and Secrets to access backend services.\n- Finally, you use a Template object that contains at least a **DeploymentConfig** (with **Pod** definition), **Service** and **Route** to deploy the application.\n- You deploy the application using the command:\n\n```bash\n oc new-app -f template.yaml\n```\nIn Kubernetes, staging is performed as follows:\n\n- You create a **docker image** using a Dockerfile and store the image in a **Docker repository**\n```bash\n docker build -t (image)\n docker push (image)\n```\n- You create ConfigMap and Secrets to access backend services\n- You use YAML file to deploy Kubernetes resources such as **Kubernetes Pod** in a Deployment, **Kubernetes Service** and maybe an **Ingress**\n```bash\n kubectl apply -f (template)\n```\n\n## Activities\n\n| Task                            | Description         | Link        |\n| --------------------------------| ------------------  |:----------- |\n| *** Try It Yourself ***                         |         |         |\n| Migrating to IKS | Migrating from Cloud Foundry to IKS | [IKS](../cf-to-k8s/iks-migration/) |\n| Migrating to OpenShift | Migrating from Cloud Foundry to OpenShift | [OCP](../cf-to-k8s/oc-migration/) |","frontmatter":{"title":"Kubernetes for CloudFoundry users","description":"Cloud Foundry to Kubernetes"},"fileAbsolutePath":"/home/travis/build/ibm-cloud-architecture/learning-cloudnative-101/src/pages/electives/cf-to-k8s/index.mdx"}}},"staticQueryHashes":["1364590287","2102389209","2102389209","2456312558","2746626797","2746626797","3018647132","3018647132","3037994772","3037994772","63531786","63531786","768070550"]}